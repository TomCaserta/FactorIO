<!DOCTYPE html><html lang="en"><head ><title >Data Lifecycle</title><meta charset="UTF-8"/><link rel="stylesheet" type="text/css" href="lua-doc.css"/></head><body ><div class="navigation-bar"><span class="navigation"><a href="index.html">Factorio</a> &raquo; Data Lifecycle</span><span class="version">Factorio 0.14.21</span></div><h1 >Data Lifecycle</h1><p ></p><p >
Factorio sorts mods first by dependencies then by natural sort order accounting for case (<a href="https://en.wikipedia.org/wiki/Natural_sort_order">https://en.wikipedia.org/wiki/Natural_sort_order</a>).</p><p >This describes the data flow for mods. In what order the different stages of data processing are done, what parts are available, and what&#x27;s expected during each stage.</p> <h2>1. The data stage</h2> <p >When Factorio first starts a single shared Lua state is created to process and collect prototype data from each mod into a global table <code >data</code>.</p><p >First the data.lua file is called for each mod. Next, the data-updates.lua file is called for each mod and finally the data-final-fixes.lua file is called for each mod. During this time there&#x27;s no game instance created and the standard Lua API is not available. The <code >data</code> table expects a specific format for each item in the table. Missing properties will either fall back to default values or give an error indicating what&#x27;s missing. Extra properties that the game isn&#x27;t looking for are simply ignored.</p><p >Changes made during each stage of the data loading are automatically tracked and a history of which mod has changed which prototype is recorded by the game. After the data stage of loading has finished the Lua state is discarded. Changes and functions defined during the data stage will not carry over to any other stages.</p><p >At the end of this stage all prototypes are constructed and the game goes to the main menu.</p> <h2>2. Migrations</h2> <p >Migrations are a way to handle prototype changes between mod versions or game versions. Migrations do have access to the game state but are isolated from all other data stages. Migrations are each run in their own Lua state that&#x27;s discarded after the migration haves been applied.</p><p >See: <a href="Migrations.html"> Migrations</a></p> <h2>3. control.lua initialization</h2> <p >During this stage each mod&#x27;s control.lua is loaded and executed in their own Lua instance that will be owned by that mod for the remainder of the play session. Each mod has its own Lua instance and own <code >global</code> table to store data. Because this is run every time a save file is created or loaded you don&#x27;t need to restart the game to see changes made to the control.lua file. Simply restarting or reloading a save will re-run this stage.</p><p >During this stage access to the <code >global</code> table is not available. The <a href="LuaGameScript.html"><code >script</code></a> table and the <a href="LuaRemote.html"><code >remote</code></a> table are however available. Note, although the <code >global</code> table has not been setup if a mod does populate the table with some data it will be overwritten by any loaded data.</p><p >At the end of this stage (if loading a save file) mod data saved in the map file is loaded and the <code >global</code> table for each mod is restored.</p> <h2> 4. control.lua init/loaded </h2> <p >Using the mod order each mod is setup:</p><ul ><li > When creating a new game, <a href="LuaBootstrap.html#LuaBootstrap.on_init"><code >script.on_init()</code></a> will be called on each mod that has a control.lua file.</li><li > When loading a save game and the mod existed in that save game <a href="LuaBootstrap.html#LuaBootstrap.on_load"><code >script.on_load()</code></a> is called.</li><li > When loading a save game and the mod did not exist in that save game <a href="LuaBootstrap.html#LuaBootstrap.on_init"><code >script.on_init()</code></a> is called.</li></ul><p >During the <a href="LuaBootstrap.html#LuaBootstrap.on_load"><code >script.on_load()</code></a> event handler access to the <code >game</code> table is not available. This handler is meant for only 3 things:</p><ul ><li > 1. Re-setup meta-tables. Meta-tables are not persisted through save-load.</li><li > 2. Re-setup conditional event handlers (subscribing to an event only when some condition is true to save processing time).</li><li > 3. Create local references to data stored in the global table</li></ul><p >Attempting to change the contents of the <code >global</code> table during the <a href="LuaBootstrap.html#LuaBootstrap.on_load"><code >script.on_load()</code></a> event handler is not allowed. Doing so can lead to desyncs if the mod is used in multiplayer and will generate an error if the game detects it has been changed in any way.</p><p >During the <a href="LuaBootstrap.html#LuaBootstrap.on_init"><code >script.on_init()</code></a> event handler access to the <code >game</code> table is available and any and all changes deemed necessary by the mod are free to be performed without risk of breaking anything.</p> <h2>5. control.lua <code>script.on_configuration_changed()</code></h2> <p >When mods are changed (prototypes added or removed), the major game version changes, a mod version changes, a mod is removed, or a mod is added the <a href="LuaBootstrap.html#LuaBootstrap.on_configuration_changed"><code >script.on_configuration_changed()</code></a> event is fired for each mod subscribed to that event.</p><p >This is the main place for handling mod internal data structure changes. Access to the <code >global</code> table, <code >game</code> table and game state are available and can be changed in any way seen fit by the mod.</p><p >Note: this is not the place to handle things such as recipe unlocks due to research changes - that is best done through migration scripts.</p> <h2>6. control.lua runtime:</h2> <p >At this stage the game is running fully and everything has been setup or loaded. Access to all tables is available in any event handler.
</p><div class="brief-listing"></div></body></html>